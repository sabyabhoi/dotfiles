snippet cc "Competitive Coding Template"
  #include <bits/stdc++.h>
  
  #define deb(x) cout << #x << " = " << x << endl
  
  #define MOD 1000000007
  
  #define REP(i, n) for(int i = 0; i < (n); ++i)
  #define FOR(i, s, n) for(int i = (s); i < (n); ++i)
  
  using namespace std;
  
  typedef long long ll;
  typedef unsigned long long ull;
  typedef vector<int> vi;
  typedef vector<vector<int>> vvi;
  typedef vector<string> vs;
  typedef vector<vector<string>> vvs;
  
  template<typename T>
  void print_vec(const vector<T>& v) {
    for(const T& i : v) cout << i << ' ';
    cout << '\n';
  }
  
  int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
  
		$1
    return 0;
  }

snippet bt "Binary Tree"
  struct Node {
   int data;
    struct Node *left;
    struct Node *right;
    
    Node (int x) : data(x), left(nullptr), right(nullptr) {}
    Node (int x, Node *l, Node *r) : data(x), left(l), right(r) {}
  };
  
  int height(Node *root) {
    if(root == nullptr) return 0;
    return max(height(root->left), height(root->right)) + 1;
  }
  
  void printBFS(Node *root) {
    if(root == nullptr) return;
    queue<Node*> q;
    q.push(root);
  
    while(!q.empty()) {
      Node *curr = q.front();
      cout << curr->data << ' ';
      if(curr->left != nullptr) q.push(curr->left);
      if(curr->right != nullptr) q.push(curr->right);
      q.pop();
    }
    cout << endl;
  }
  
  void deleteTree(Node* head) {
    if(head == nullptr) return;
  
    deleteTree(head->left);
    deleteTree(head->right);
    delete head;
  }
  
  Node *construct(const vi& a) {
    if(a.empty()) return nullptr;
    Node* root = new Node(a[0]);
  
    queue<Node*> q;
    q.push(root);
  
    int count = 0;
    for(int i = 1; i < (int) a.size(); ++i) {
    s:
  	Node *curr = q.front();
  	switch (count) {
      case 0:
        count = 1;
        if (a[i] != -1) {
          Node *tmp = new Node(a[i]);
          curr->left = tmp;
          q.push(tmp);
        }
        break;
      case 1:
        count = 2;
        if (a[i] != -1) {
          Node *tmp = new Node(a[i]);
          curr->right = tmp;
          q.push(tmp);
        }
        break;
      case 2:
        q.pop();
        count = 0;
        goto s;
      default:
        break;
      }
    }
    return root;
  }

snippet trie "Trie Data Structure"
	struct Trie {
		Trie *children[26];
		bool end;

		Trie() {
			REP(i, 26) children[i] = nullptr;
			end = false;
		}

		void insert(const string &s) {
			Trie *itr = this;
			for (char c : s) {
				int i = c - 'a';
				if (itr->children[i] == nullptr)
					itr->children[i] = new Trie();
				itr = itr->children[i];
			}
			itr->end = true;
		}

		bool search(const string &s) {
			Trie *itr = this;
			for (char c : s) {
				int i = c - 'a';
				if (itr->children[i] == nullptr)
					return false;
				itr = itr->children[i];
			}
			return true;
		}
		bool empty() {
			REP(i, 26) {
				if (this->children[i] != nullptr)
					return false;
			}
			return true;
		}
	};
	Trie *delete_key(Trie *t, int i, const string &s) {
		if (t == nullptr)
			return nullptr;

		if (i == s.length()) {
			t->end = false;
			if (t->empty()) {
				delete t;
				t = nullptr;
			}
			return t;
		}

		int ix = s[i] - 'a';
		t->children[ix] = delete_key(t->children[ix], i + 1, s);
		if (t->empty() && !t->end) {
			delete t;
			t = nullptr;
		}
		return t;
	}

	void delete_trie(Trie *t) {
		if (t == nullptr)
			return;

		REP(i, 26) { delete_trie(t->children[i]); }
		delete t;
	}
