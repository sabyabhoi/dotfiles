snippet cc "Competitive Coding Template"
  #include <bits/stdc++.h>
  
  #define deb(x) cout << #x << " = " << x << endl
  
  #define MOD 1000000007
  
  #define REP(i, n) for(int i = 0; i < (n); ++i)
  #define FOR(i, s, n) for(int i = (s); i < (n); ++i)
  
  using namespace std;
  
  typedef long long ll;
  typedef unsigned long long ull;
  typedef vector<int> vi;
  typedef vector<vector<int>> vvi;
  typedef vector<string> vs;
  typedef vector<vector<string>> vvs;
  
  template<typename T>
  void print_vec(const vector<T>& v) {
    for(const T& i : v) cout << i << ' ';
    cout << '\n';
  }
  
  void solve() {
		$1
  }
  
  int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
  
    int t;
    cin >> t;
    while (t--)
      solve();
    return 0;
  }

snippet bt "Binary Tree"
  struct Node {
   int data;
    struct Node *left;
    struct Node *right;
    
    Node (int x) : data(x), left(nullptr), right(nullptr) {}
    Node (int x, Node *l, Node *r) : data(x), left(l), right(r) {}
  };
  
  int height(Node *root) {
    if(root == nullptr) return 0;
    return max(height(root->left), height(root->right)) + 1;
  }
  
  void printBFS(Node *root) {
    if(root == nullptr) return;
    queue<Node*> q;
    q.push(root);
  
    while(!q.empty()) {
      Node *curr = q.front();
      cout << curr->data << ' ';
      if(curr->left != nullptr) q.push(curr->left);
      if(curr->right != nullptr) q.push(curr->right);
      q.pop();
    }
    cout << endl;
  }
  
  void deleteTree(Node* head) {
    if(head == nullptr) return;
  
    deleteTree(head->left);
    deleteTree(head->right);
    delete head;
  }
  
  Node *construct(const vi& a) {
    if(a.empty()) return nullptr;
    Node* root = new Node(a[0]);
  
    queue<Node*> q;
    q.push(root);
  
    int count = 0;
    for(int i = 1; i < (int) a.size(); ++i) {
    s:
  	Node *curr = q.front();
  	switch (count) {
      case 0:
        count = 1;
        if (a[i] != -1) {
          Node *tmp = new Node(a[i]);
          curr->left = tmp;
          q.push(tmp);
        }
        break;
      case 1:
        count = 2;
        if (a[i] != -1) {
          Node *tmp = new Node(a[i]);
          curr->right = tmp;
          q.push(tmp);
        }
        break;
      case 2:
        q.pop();
        count = 0;
        goto s;
      default:
        break;
      }
    }
    return root;
  }
