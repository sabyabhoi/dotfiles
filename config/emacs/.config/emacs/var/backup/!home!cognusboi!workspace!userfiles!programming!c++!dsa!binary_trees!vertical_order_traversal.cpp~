#include <bits/stdc++.h>

#define deb(x) cout << #x << " = " << x << endl

#define MOD 1000000007

#define REP(i, n) for(int i = 0; i < (n); ++i)
#define FOR(i, s, n) for(int i = (s); i < (n); ++i)

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef vector<int> vi;
typedef vector<vector<int>> vvi;
typedef vector<string> vs;
typedef vector<vector<string>> vvs;

template<typename T>
void print_vec(const vector<T>& v) {
  for(const T& i : v) cout << i << ' ';
  cout << '\n';
}

struct Node {
 int data;
  struct Node *left;
  struct Node *right;
  
  Node (int x) : data(x), left(nullptr), right(nullptr) {}
  Node (int x, Node *l, Node *r) : data(x), left(l), right(r) {}
};

int height(Node *root) {
  if(root == nullptr) return 0;
  return max(height(root->left), height(root->right)) + 1;
}

void printBFS(Node *root) {
  if(root == nullptr) return;
  queue<Node*> q;
  q.push(root);

  while(!q.empty()) {
    Node *curr = q.front();
    cout << curr->data << ' ';
    if(curr->left != nullptr) q.push(curr->left);
    if(curr->right != nullptr) q.push(curr->right);
    q.pop();
  }
  cout << endl;
}

void deleteTree(Node* head) {
  if(head == nullptr) return;

  deleteTree(head->left);
  deleteTree(head->right);
  delete head;
}

struct Element {
  int level, col;
  Node* curr;

  Element(int l, int c, Node* cur) : level(l), col(c), curr(cur) {}
};

vector<vector<int>> verticalTraversal(Node *root) {
  vector<vector<int>> ans;
  if (root == nullptr)
    return ans;

  map<int, map<int, multiset<int>>> m;
  queue<Element> q;
  q.push({0, 0, root});

  while (!q.empty()) {
    Node *curr = q.front().curr;
    int level = q.front().level;
    int column = q.front().col;

    m[column][level].insert(curr->data);

    q.pop();
    if (curr->left)
      q.push(Element(level + 1, column - 1, curr->left));
    if (curr->right)
      q.push(Element(level + 1, column + 1, curr->right));
  }

  for (auto a : m) {
    vector<int> col;

    for (auto b : a.second)
      col.insert(col.end(), b.second.begin(), b.second.end());

    ans.push_back(col);
  }
  return ans;
}

//vvi vertical_order_traversal(Node* tree) {
//  vvi ans;
//  if(tree == nullptr) return ans;
//  
//  // m[column][level]
//  map<int, map<int, multiset<int>>> m;
//  queue<Element> q;
//  q.push(Element(0, 0, tree));
//  
//  while(!q.empty()) {
//	auto f = q.front();
//	int col = f.col;
//	int lvl = f.level;
//	Node* curr = f.curr;
//
//	m[col][lvl].insert(curr->data);
//
//	q.pop();
//	if(curr->left) q.push(Element(col - 1, lvl + 1, curr->left));
//	if(curr->right) q.push(Element(col + 1, lvl + 1, curr->right));
//  }
//
//  for(auto col : m) {
//	vi cols;
//	for(auto l : col.second) {
//	  cols.insert(cols.end(), l.second.begin(), l.second.end());
//	}
//	ans.push_back(cols);
//  }
//  return ans;
//}

/*
 *  10
 */

void solve() {
  Node* tree = new Node(10);
  tree->left = new Node(20);
  tree->right = new Node(30);
  tree->left->left = new Node(40);
  tree->left->right = new Node(50);
  
  vvi ans = vertical_order_traversal(tree);
  for(vi v : ans) {
	cout << "(";
	for(int i : v) cout << i << ' ';
	cout << ") ";
  }
  cout << '\n';

  deleteTree(tree);
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);

  solve();
  return 0;
}
