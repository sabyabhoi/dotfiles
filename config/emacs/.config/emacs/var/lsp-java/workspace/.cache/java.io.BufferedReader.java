 // Source code is unavailable, and was generated by the Fernflower decompiler.
package java.io;

import java.io.BufferedReader.1;
import java.util.Iterator;
import java.util.Objects;
import java.util.Spliterators;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import jdk.internal.misc.InternalLock;

public class BufferedReader extends Reader {
   private Reader in;
   private char[] cb;
   private int nChars;
   private int nextChar;
   private static final int INVALIDATED = -2;
   private static final int UNMARKED = -1;
   private int markedChar;
   private int readAheadLimit;
   private boolean skipLF;
   private boolean markedSkipLF;
   private static int defaultCharBufferSize = 8192;
   private static int defaultExpectedLineLength = 80;

   public BufferedReader(Reader in, int sz) {
      super(in);
      this.markedChar = -1;
      this.readAheadLimit = 0;
      this.skipLF = false;
      this.markedSkipLF = false;
      if (sz <= 0) {
         throw new IllegalArgumentException("Buffer size <= 0");
      } else {
         this.in = in;
         this.cb = new char[sz];
         this.nextChar = this.nChars = 0;
      }
   }

   public BufferedReader(Reader in) {
      this(in, defaultCharBufferSize);
   }

   private void ensureOpen() throws IOException {
      if (this.in == null) {
         throw new IOException("Stream closed");
      }
   }

   private void fill() throws IOException {
      int dst;
      int n;
      if (this.markedChar <= -1) {
         dst = 0;
      } else {
         n = this.nextChar - this.markedChar;
         if (n >= this.readAheadLimit) {
            this.markedChar = -2;
            this.readAheadLimit = 0;
            dst = 0;
         } else {
            if (this.readAheadLimit <= this.cb.length) {
               System.arraycopy(this.cb, this.markedChar, this.cb, 0, n);
               this.markedChar = 0;
               dst = n;
            } else {
               char[] ncb = new char[this.readAheadLimit];
               System.arraycopy(this.cb, this.markedChar, ncb, 0, n);
               this.cb = ncb;
               this.markedChar = 0;
               dst = n;
            }

            this.nextChar = this.nChars = n;
         }
      }

      do {
         n = this.in.read(this.cb, dst, this.cb.length - dst);
      } while(n == 0);

      if (n > 0) {
         this.nChars = dst + n;
         this.nextChar = dst;
      }

   }

   public int read() throws IOException {
      Object lock = this.lock;
      if (lock instanceof InternalLock) {
         InternalLock locker = (InternalLock)lock;
         locker.lock();

         int var3;
         try {
            var3 = this.implRead();
         } finally {
            locker.unlock();
         }

         return var3;
      } else {
         synchronized(lock) {
            return this.implRead();
         }
      }
   }

   private int implRead() throws IOException {
      this.ensureOpen();

      while(true) {
         if (this.nextChar >= this.nChars) {
            this.fill();
            if (this.nextChar >= this.nChars) {
               return -1;
            }
         }

         if (!this.skipLF) {
            break;
         }

         this.skipLF = false;
         if (this.cb[this.nextChar] != '\n') {
            break;
         }

         ++this.nextChar;
      }

      return this.cb[this.nextChar++];
   }

   private int read1(char[] cbuf, int off, int len) throws IOException {
      if (this.nextChar >= this.nChars) {
         if (len >= this.cb.length && this.markedChar <= -1 && !this.skipLF) {
            return this.in.read(cbuf, off, len);
         }

         this.fill();
      }

      if (this.nextChar >= this.nChars) {
         return -1;
      } else {
         if (this.skipLF) {
            this.skipLF = false;
            if (this.cb[this.nextChar] == '\n') {
               ++this.nextChar;
               if (this.nextChar >= this.nChars) {
                  this.fill();
               }

               if (this.nextChar >= this.nChars) {
                  return -1;
               }
            }
         }

         int n = Math.min(len, this.nChars - this.nextChar);
         System.arraycopy(this.cb, this.nextChar, cbuf, off, n);
         this.nextChar += n;
         return n;
      }
   }

   public int read(char[] cbuf, int off, int len) throws IOException {
      Object lock = this.lock;
      if (lock instanceof InternalLock) {
         InternalLock locker = (InternalLock)lock;
         locker.lock();

         int var6;
         try {
            var6 = this.implRead(cbuf, off, len);
         } finally {
            locker.unlock();
         }

         return var6;
      } else {
         synchronized(lock) {
            return this.implRead(cbuf, off, len);
         }
      }
   }

   private int implRead(char[] cbuf, int off, int len) throws IOException {
      this.ensureOpen();
      Objects.checkFromIndexSize(off, len, cbuf.length);
      if (len == 0) {
         return 0;
      } else {
         int n = this.read1(cbuf, off, len);
         if (n <= 0) {
            return n;
         } else {
            while(n < len && this.in.ready()) {
               int n1 = this.read1(cbuf, off + n, len - n);
               if (n1 <= 0) {
                  break;
               }

               n += n1;
            }

            return n;
         }
      }
   }

   String readLine(boolean ignoreLF, boolean[] term) throws IOException {
      Object lock = this.lock;
      if (lock instanceof InternalLock) {
         InternalLock locker = (InternalLock)lock;
         locker.lock();

         String var5;
         try {
            var5 = this.implReadLine(ignoreLF, term);
         } finally {
            locker.unlock();
         }

         return var5;
      } else {
         synchronized(lock) {
            return this.implReadLine(ignoreLF, term);
         }
      }
   }

   private String implReadLine(boolean ignoreLF, boolean[] term) throws IOException {
      StringBuilder s = null;
      this.ensureOpen();
      boolean omitLF = ignoreLF || this.skipLF;
      if (term != null) {
         term[0] = false;
      }

      while(true) {
         if (this.nextChar >= this.nChars) {
            this.fill();
         }

         if (this.nextChar >= this.nChars) {
            if (s != null && s.length() > 0) {
               return s.toString();
            }

            return null;
         }

         boolean eol = false;
         char c = 0;
         if (omitLF && this.cb[this.nextChar] == '\n') {
            ++this.nextChar;
         }

         this.skipLF = false;
         omitLF = false;

         int i;
         for(i = this.nextChar; i < this.nChars; ++i) {
            c = this.cb[i];
            if (c == '\n' || c == '\r') {
               if (term != null) {
                  term[0] = true;
               }

               eol = true;
               break;
            }
         }

         int startChar = this.nextChar;
         this.nextChar = i;
         if (eol) {
            String str;
            if (s == null) {
               str = new String(this.cb, startChar, i - startChar);
            } else {
               s.append(this.cb, startChar, i - startChar);
               str = s.toString();
            }

            ++this.nextChar;
            if (c == '\r') {
               this.skipLF = true;
            }

            return str;
         }

         if (s == null) {
            s = new StringBuilder(defaultExpectedLineLength);
         }

         s.append(this.cb, startChar, i - startChar);
      }
   }

   public String readLine() throws IOException {
      return this.readLine(false, (boolean[])null);
   }

   public long skip(long n) throws IOException {
      if (n < 0L) {
         throw new IllegalArgumentException("skip value is negative");
      } else {
         Object lock = this.lock;
         if (lock instanceof InternalLock) {
            InternalLock locker = (InternalLock)lock;
            locker.lock();

            long var5;
            try {
               var5 = this.implSkip(n);
            } finally {
               locker.unlock();
            }

            return var5;
         } else {
            synchronized(lock) {
               return this.implSkip(n);
            }
         }
      }
   }

   private long implSkip(long n) throws IOException {
      this.ensureOpen();

      long r;
      for(r = n; r > 0L; this.nextChar = this.nChars) {
         if (this.nextChar >= this.nChars) {
            this.fill();
         }

         if (this.nextChar >= this.nChars) {
            break;
         }

         if (this.skipLF) {
            this.skipLF = false;
            if (this.cb[this.nextChar] == '\n') {
               ++this.nextChar;
            }
         }

         long d = (long)(this.nChars - this.nextChar);
         if (r <= d) {
            this.nextChar += (int)r;
            r = 0L;
            break;
         }

         r -= d;
      }

      return n - r;
   }

   public boolean ready() throws IOException {
      Object lock = this.lock;
      if (lock instanceof InternalLock) {
         InternalLock locker = (InternalLock)lock;
         locker.lock();

         boolean var3;
         try {
            var3 = this.implReady();
         } finally {
            locker.unlock();
         }

         return var3;
      } else {
         synchronized(lock) {
            return this.implReady();
         }
      }
   }

   private boolean implReady() throws IOException {
      this.ensureOpen();
      if (this.skipLF) {
         if (this.nextChar >= this.nChars && this.in.ready()) {
            this.fill();
         }

         if (this.nextChar < this.nChars) {
            if (this.cb[this.nextChar] == '\n') {
               ++this.nextChar;
            }

            this.skipLF = false;
         }
      }

      return this.nextChar < this.nChars || this.in.ready();
   }

   public boolean markSupported() {
      return true;
   }

   public void mark(int readAheadLimit) throws IOException {
      if (readAheadLimit < 0) {
         throw new IllegalArgumentException("Read-ahead limit < 0");
      } else {
         Object lock = this.lock;
         if (lock instanceof InternalLock) {
            InternalLock locker = (InternalLock)lock;
            locker.lock();

            try {
               this.implMark(readAheadLimit);
            } finally {
               locker.unlock();
            }
         } else {
            synchronized(lock) {
               this.implMark(readAheadLimit);
            }
         }

      }
   }

   private void implMark(int readAheadLimit) throws IOException {
      this.ensureOpen();
      this.readAheadLimit = readAheadLimit;
      this.markedChar = this.nextChar;
      this.markedSkipLF = this.skipLF;
   }

   public void reset() throws IOException {
      Object lock = this.lock;
      if (lock instanceof InternalLock) {
         InternalLock locker = (InternalLock)lock;
         locker.lock();

         try {
            this.implReset();
         } finally {
            locker.unlock();
         }
      } else {
         synchronized(lock) {
            this.implReset();
         }
      }

   }

   private void implReset() throws IOException {
      this.ensureOpen();
      if (this.markedChar < 0) {
         throw new IOException(this.markedChar == -2 ? "Mark invalid" : "Stream not marked");
      } else {
         this.nextChar = this.markedChar;
         this.skipLF = this.markedSkipLF;
      }
   }

   public void close() throws IOException {
      Object lock = this.lock;
      if (lock instanceof InternalLock) {
         InternalLock locker = (InternalLock)lock;
         locker.lock();

         try {
            this.implClose();
         } finally {
            locker.unlock();
         }
      } else {
         synchronized(lock) {
            this.implClose();
         }
      }

   }

   private void implClose() throws IOException {
      if (this.in != null) {
         try {
            this.in.close();
         } finally {
            this.in = null;
            this.cb = null;
         }

      }
   }

   public Stream<String> lines() {
      Iterator<String> iter = new 1(this);
      return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iter, 272), false);
   }
}
