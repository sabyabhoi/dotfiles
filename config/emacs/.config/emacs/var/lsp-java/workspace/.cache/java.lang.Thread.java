 // Source code is unavailable, and was generated by the Fernflower decompiler.
package java.lang;

import java.lang.Thread.1;
import java.lang.Thread.Caches;
import java.lang.Thread.Constants;
import java.lang.Thread.FieldHolder;
import java.lang.Thread.State;
import java.lang.Thread.ThreadIdentifiers;
import java.lang.Thread.ThreadNumbering;
import java.lang.Thread.UncaughtExceptionHandler;
import java.lang.Thread.Builder.OfPlatform;
import java.lang.Thread.Builder.OfVirtual;
import java.lang.ThreadBuilders.PlatformThreadBuilder;
import java.lang.ThreadBuilders.VirtualThreadBuilder;
import java.lang.ThreadLocal.ThreadLocalMap;
import java.security.AccessControlContext;
import java.security.AccessController;
import java.time.Duration;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;
import jdk.internal.event.ThreadSleepEvent;
import jdk.internal.javac.PreviewFeature;
import jdk.internal.javac.PreviewFeature.Feature;
import jdk.internal.loader.ClassLoaders;
import jdk.internal.misc.PreviewFeatures;
import jdk.internal.misc.StructureViolationExceptions;
import jdk.internal.misc.TerminatingThreadLocal;
import jdk.internal.misc.VM;
import jdk.internal.reflect.CallerSensitive;
import jdk.internal.reflect.Reflection;
import jdk.internal.vm.Continuation;
import jdk.internal.vm.StackableScope;
import jdk.internal.vm.ThreadContainer;
import jdk.internal.vm.ExtentLocalContainer.BindingsSnapshot;
import jdk.internal.vm.annotation.IntrinsicCandidate;
import sun.nio.ch.Interruptible;
import sun.security.util.SecurityConstants;

public class Thread implements Runnable {
   private long eetop;
   private final long tid;
   private volatile String name;
   volatile boolean interrupted;
   private volatile ClassLoader contextClassLoader;
   private AccessControlContext inheritedAccessControlContext;
   private final FieldHolder holder;
   ThreadLocalMap threadLocals;
   ThreadLocalMap inheritableThreadLocals;
   private Object extentLocalBindings;
   final Object interruptLock;
   private volatile Object parkBlocker;
   volatile Interruptible nioBlocker;
   public static final int MIN_PRIORITY = 1;
   public static final int NORM_PRIORITY = 5;
   public static final int MAX_PRIORITY = 10;
   private Continuation cont;
   static final int NO_THREAD_LOCALS = 2;
   static final int NO_INHERIT_THREAD_LOCALS = 4;
   private static final StackTraceElement[] EMPTY_STACK_TRACE;
   private volatile UncaughtExceptionHandler uncaughtExceptionHandler;
   private static volatile UncaughtExceptionHandler defaultUncaughtExceptionHandler;
   long threadLocalRandomSeed;
   int threadLocalRandomProbe;
   int threadLocalRandomSecondarySeed;
   private volatile ThreadContainer container;
   private volatile StackableScope headStackableScopes;

   private static native void registerNatives();

   static Object extentLocalBindings() {
      return currentThread().extentLocalBindings;
   }

   static void setExtentLocalBindings(Object bindings) {
      currentThread().extentLocalBindings = bindings;
   }

   void inheritExtentLocalBindings(ThreadContainer container) {
      BindingsSnapshot snapshot;
      if (container.owner() != null && (snapshot = container.extentLocalBindings()) != null) {
         Object bindings = snapshot.extentLocalBindings();
         if (currentThread().extentLocalBindings != bindings) {
            StructureViolationExceptions.throwException("Extent local bindings have changed");
         }

         this.extentLocalBindings = bindings;
      }

   }

   static void blockedOn(Interruptible b) {
      Thread me = currentThread();
      Object var2 = me.interruptLock;
      synchronized(me.interruptLock) {
         me.nioBlocker = b;
      }
   }

   Continuation getContinuation() {
      return this.cont;
   }

   void setContinuation(Continuation cont) {
      this.cont = cont;
   }

   @IntrinsicCandidate
   static native Thread currentCarrierThread();

   @IntrinsicCandidate
   public static native Thread currentThread();

   @IntrinsicCandidate
   native void setCurrentThread(Thread var1);

   @IntrinsicCandidate
   static native Object[] extentLocalCache();

   @IntrinsicCandidate
   static native void setExtentLocalCache(Object[] var0);

   public static void yield() {
      Thread var1 = currentThread();
      if (var1 instanceof VirtualThread) {
         VirtualThread vthread = (VirtualThread)var1;
         vthread.tryYield();
      } else {
         yield0();
      }

   }

   private static native void yield0();

   public static void sleep(long millis) throws InterruptedException {
      if (millis < 0L) {
         throw new IllegalArgumentException("timeout value is negative");
      } else {
         Thread var3 = currentThread();
         if (var3 instanceof VirtualThread) {
            VirtualThread vthread = (VirtualThread)var3;
            long nanos = TimeUnit.MILLISECONDS.toNanos(millis);
            vthread.sleepNanos(nanos);
         } else {
            if (ThreadSleepEvent.isTurnedOn()) {
               ThreadSleepEvent event = new ThreadSleepEvent();

               try {
                  event.time = TimeUnit.MILLISECONDS.toNanos(millis);
                  event.begin();
                  sleep0(millis);
               } finally {
                  event.commit();
               }
            } else {
               sleep0(millis);
            }

         }
      }
   }

   private static native void sleep0(long var0) throws InterruptedException;

   public static void sleep(long millis, int nanos) throws InterruptedException {
      if (millis < 0L) {
         throw new IllegalArgumentException("timeout value is negative");
      } else if (nanos >= 0 && nanos <= 999999) {
         Thread var4 = currentThread();
         if (var4 instanceof VirtualThread) {
            VirtualThread vthread = (VirtualThread)var4;
            long totalNanos = TimeUnit.MILLISECONDS.toNanos(millis);
            totalNanos += Math.min(Long.MAX_VALUE - totalNanos, (long)nanos);
            vthread.sleepNanos(totalNanos);
         } else {
            if (nanos > 0 && millis < Long.MAX_VALUE) {
               ++millis;
            }

            sleep(millis);
         }
      } else {
         throw new IllegalArgumentException("nanosecond timeout value out of range");
      }
   }

   public static void sleep(Duration duration) throws InterruptedException {
      long nanos = TimeUnit.NANOSECONDS.convert(duration);
      if (nanos >= 0L) {
         Thread var4 = currentThread();
         if (var4 instanceof VirtualThread) {
            VirtualThread vthread = (VirtualThread)var4;
            vthread.sleepNanos(nanos);
         } else {
            long millis = TimeUnit.MILLISECONDS.convert(nanos, TimeUnit.NANOSECONDS);
            if (nanos > TimeUnit.NANOSECONDS.convert(millis, TimeUnit.MILLISECONDS)) {
               ++millis;
            }

            sleep(millis);
         }
      }
   }

   @IntrinsicCandidate
   public static void onSpinWait() {
   }

   private static ClassLoader contextClassLoader(Thread parent) {
      SecurityManager sm = System.getSecurityManager();
      if (sm != null && !isCCLOverridden(parent.getClass())) {
         ClassLoader cl = parent.contextClassLoader;
         return isSupportedClassLoader(cl) ? cl : ClassLoader.getSystemClassLoader();
      } else {
         return parent.getContextClassLoader();
      }
   }

   Thread(ThreadGroup g, String name, int characteristics, Runnable task, long stackSize, AccessControlContext acc) {
      this.interruptLock = new Object();
      Thread parent = currentThread();
      boolean attached = parent == this;
      if (attached) {
         if (g == null) {
            throw new InternalError("group cannot be null when attaching");
         }

         this.holder = new FieldHolder(g, task, stackSize, 5, false);
      } else {
         SecurityManager sm = System.getSecurityManager();
         if (g == null) {
            if (sm != null) {
               g = sm.getThreadGroup();
            }

            if (g == null) {
               g = parent.getThreadGroup();
            }
         }

         if (sm != null) {
            sm.checkAccess(g);
            if (isCCLOverridden(this.getClass())) {
               sm.checkPermission(SecurityConstants.SUBCLASS_IMPLEMENTATION_PERMISSION);
            }
         }

         int priority = Math.min(parent.getPriority(), g.getMaxPriority());
         this.holder = new FieldHolder(g, task, stackSize, priority, parent.isDaemon());
      }

      if (attached && VM.initLevel() < 1) {
         this.tid = 1L;
      } else {
         this.tid = ThreadIdentifiers.next();
      }

      this.name = name != null ? name : genThreadName();
      if (acc != null) {
         this.inheritedAccessControlContext = acc;
      } else {
         this.inheritedAccessControlContext = AccessController.getContext();
      }

      if (!attached) {
         if ((characteristics & 2) != 0) {
            this.threadLocals = ThreadLocalMap.NOT_SUPPORTED;
            this.inheritableThreadLocals = ThreadLocalMap.NOT_SUPPORTED;
            this.contextClassLoader = Constants.NOT_SUPPORTED_CLASSLOADER;
         } else if ((characteristics & 4) == 0) {
            ThreadLocalMap parentMap = parent.inheritableThreadLocals;
            if (parentMap != null && parentMap != ThreadLocalMap.NOT_SUPPORTED && parentMap.size() > 0) {
               this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parentMap);
            }

            ClassLoader parentLoader = contextClassLoader(parent);
            if (VM.isBooted() && !isSupportedClassLoader(parentLoader)) {
               this.contextClassLoader = ClassLoader.getSystemClassLoader();
            } else {
               this.contextClassLoader = parentLoader;
            }
         } else if (VM.isBooted()) {
            this.contextClassLoader = ClassLoader.getSystemClassLoader();
         }
      }

   }

   Thread(String name, int characteristics, boolean bound) {
      this.interruptLock = new Object();
      this.tid = ThreadIdentifiers.next();
      this.name = name != null ? name : "";
      this.inheritedAccessControlContext = Constants.NO_PERMISSIONS_ACC;
      if ((characteristics & 2) != 0) {
         this.threadLocals = ThreadLocalMap.NOT_SUPPORTED;
         this.inheritableThreadLocals = ThreadLocalMap.NOT_SUPPORTED;
         this.contextClassLoader = Constants.NOT_SUPPORTED_CLASSLOADER;
      } else if ((characteristics & 4) == 0) {
         Thread parent = currentThread();
         ThreadLocalMap parentMap = parent.inheritableThreadLocals;
         if (parentMap != null && parentMap != ThreadLocalMap.NOT_SUPPORTED && parentMap.size() > 0) {
            this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parentMap);
         }

         ClassLoader parentLoader = contextClassLoader(parent);
         if (isSupportedClassLoader(parentLoader)) {
            this.contextClassLoader = parentLoader;
         } else {
            this.contextClassLoader = ClassLoader.getSystemClassLoader();
         }
      } else {
         this.contextClassLoader = ClassLoader.getSystemClassLoader();
      }

      if (bound) {
         ThreadGroup g = Constants.VTHREAD_GROUP;
         int pri = 5;
         this.holder = new FieldHolder(g, (Runnable)null, -1L, pri, true);
      } else {
         this.holder = null;
      }

   }

   @PreviewFeature(
      feature = Feature.VIRTUAL_THREADS
   )
   public static OfPlatform ofPlatform() {
      return new PlatformThreadBuilder();
   }

   @PreviewFeature(
      feature = Feature.VIRTUAL_THREADS
   )
   public static OfVirtual ofVirtual() {
      PreviewFeatures.ensureEnabled();
      return new VirtualThreadBuilder();
   }

   protected Object clone() throws CloneNotSupportedException {
      throw new CloneNotSupportedException();
   }

   static String genThreadName() {
      return "Thread-" + ThreadNumbering.next();
   }

   private static String checkName(String name) {
      if (name == null) {
         throw new NullPointerException("'name' is null");
      } else {
         return name;
      }
   }

   public Thread() {
      this((ThreadGroup)null, (String)null, 0, (Runnable)null, 0L, (AccessControlContext)null);
   }

   public Thread(Runnable task) {
      this((ThreadGroup)null, (String)null, 0, task, 0L, (AccessControlContext)null);
   }

   Thread(Runnable task, AccessControlContext acc) {
      this((ThreadGroup)null, (String)null, 0, task, 0L, acc);
   }

   public Thread(ThreadGroup group, Runnable task) {
      this(group, (String)null, 0, task, 0L, (AccessControlContext)null);
   }

   public Thread(String name) {
      this((ThreadGroup)null, checkName(name), 0, (Runnable)null, 0L, (AccessControlContext)null);
   }

   public Thread(ThreadGroup group, String name) {
      this(group, checkName(name), 0, (Runnable)null, 0L, (AccessControlContext)null);
   }

   public Thread(Runnable task, String name) {
      this((ThreadGroup)null, checkName(name), 0, task, 0L, (AccessControlContext)null);
   }

   public Thread(ThreadGroup group, Runnable task, String name) {
      this(group, checkName(name), 0, task, 0L, (AccessControlContext)null);
   }

   public Thread(ThreadGroup group, Runnable task, String name, long stackSize) {
      this(group, checkName(name), 0, task, stackSize, (AccessControlContext)null);
   }

   public Thread(ThreadGroup group, Runnable task, String name, long stackSize, boolean inheritInheritableThreadLocals) {
      this(group, checkName(name), inheritInheritableThreadLocals ? 0 : 4, task, stackSize, (AccessControlContext)null);
   }

   @PreviewFeature(
      feature = Feature.VIRTUAL_THREADS
   )
   public static Thread startVirtualThread(Runnable task) {
      Objects.requireNonNull(task);
      PreviewFeatures.ensureEnabled();
      Thread thread = ThreadBuilders.newVirtualThread((Executor)null, (String)null, 0, task);
      thread.start();
      return thread;
   }

   @PreviewFeature(
      feature = Feature.VIRTUAL_THREADS
   )
   public final boolean isVirtual() {
      return this instanceof BaseVirtualThread;
   }

   public void start() {
      synchronized(this) {
         if (this.holder.threadStatus != 0) {
            throw new IllegalThreadStateException();
         } else {
            this.start0();
         }
      }
   }

   void start(ThreadContainer container) {
      synchronized(this) {
         if (this.holder.threadStatus != 0) {
            throw new IllegalThreadStateException();
         } else {
            this.setThreadContainer(container);
            boolean started = false;
            container.onStart(this);

            try {
               this.inheritExtentLocalBindings(container);
               this.start0();
               started = true;
            } finally {
               if (!started) {
                  container.onExit(this);
               }

            }

         }
      }
   }

   private native void start0();

   public void run() {
      Runnable task = this.holder.task;
      if (task != null) {
         task.run();
      }

   }

   void clearReferences() {
      this.threadLocals = null;
      this.inheritableThreadLocals = null;
      this.inheritedAccessControlContext = null;
      if (this.uncaughtExceptionHandler != null) {
         this.uncaughtExceptionHandler = null;
      }

      if (this.nioBlocker != null) {
         this.nioBlocker = null;
      }

   }

   private void exit() {
      if (this.headStackableScopes != null) {
         StackableScope.popAll();
      }

      ThreadContainer container = this.threadContainer();
      if (container != null) {
         container.onExit(this);
      }

      try {
         if (this.threadLocals != null && TerminatingThreadLocal.REGISTRY.isPresent()) {
            TerminatingThreadLocal.threadTerminated();
         }
      } finally {
         this.clearReferences();
      }

   }

   /** @deprecated */
   @Deprecated(
      since = "1.2",
      forRemoval = true
   )
   public final void stop() {
      SecurityManager security = System.getSecurityManager();
      if (security != null) {
         this.checkAccess();
         if (this != currentThread()) {
            security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);
         }
      }

      if (this.isVirtual()) {
         throw new UnsupportedOperationException();
      } else {
         if (this.holder.threadStatus != 0) {
            this.resume();
         }

         this.stop0(new ThreadDeath());
      }
   }

   public void interrupt() {
      if (this != currentThread()) {
         this.checkAccess();
         Object var1 = this.interruptLock;
         synchronized(this.interruptLock) {
            Interruptible b = this.nioBlocker;
            if (b != null) {
               this.interrupted = true;
               this.interrupt0();
               b.interrupt(this);
               return;
            }
         }
      }

      this.interrupted = true;
      this.interrupt0();
   }

   public static boolean interrupted() {
      return currentThread().getAndClearInterrupt();
   }

   public boolean isInterrupted() {
      return this.interrupted;
   }

   final void setInterrupt() {
      if (!this.interrupted) {
         this.interrupted = true;
         this.interrupt0();
      }

   }

   final void clearInterrupt() {
      if (this.interrupted) {
         this.interrupted = false;
         clearInterruptEvent();
      }

   }

   boolean getAndClearInterrupt() {
      boolean oldValue = this.interrupted;
      if (oldValue) {
         this.interrupted = false;
         clearInterruptEvent();
      }

      return oldValue;
   }

   public final boolean isAlive() {
      return this.alive();
   }

   boolean alive() {
      return this.isAlive0();
   }

   private native boolean isAlive0();

   /** @deprecated */
   @Deprecated(
      since = "1.2",
      forRemoval = true
   )
   public final void suspend() {
      this.checkAccess();
      if (this.isVirtual()) {
         throw new UnsupportedOperationException();
      } else {
         this.suspend0();
      }
   }

   /** @deprecated */
   @Deprecated(
      since = "1.2",
      forRemoval = true
   )
   public final void resume() {
      this.checkAccess();
      if (this.isVirtual()) {
         throw new UnsupportedOperationException();
      } else {
         this.resume0();
      }
   }

   public final void setPriority(int newPriority) {
      this.checkAccess();
      if (newPriority <= 10 && newPriority >= 1) {
         if (!this.isVirtual()) {
            this.priority(newPriority);
         }

      } else {
         throw new IllegalArgumentException();
      }
   }

   void priority(int newPriority) {
      ThreadGroup g = this.holder.group;
      if (g != null) {
         int maxPriority = g.getMaxPriority();
         if (newPriority > maxPriority) {
            newPriority = maxPriority;
         }

         this.setPriority0(this.holder.priority = newPriority);
      }

   }

   public final int getPriority() {
      return this.isVirtual() ? 5 : this.holder.priority;
   }

   public final synchronized void setName(String name) {
      this.checkAccess();
      if (name == null) {
         throw new NullPointerException("name cannot be null");
      } else {
         this.name = name;
         if (!this.isVirtual() && currentThread() == this) {
            this.setNativeName(name);
         }

      }
   }

   public final String getName() {
      return this.name;
   }

   public final ThreadGroup getThreadGroup() {
      if (this.isTerminated()) {
         return null;
      } else {
         return this.isVirtual() ? virtualThreadGroup() : this.holder.group;
      }
   }

   public static int activeCount() {
      return currentThread().getThreadGroup().activeCount();
   }

   public static int enumerate(Thread[] tarray) {
      return currentThread().getThreadGroup().enumerate(tarray);
   }

   /** @deprecated */
   @Deprecated(
      since = "1.2",
      forRemoval = true
   )
   public int countStackFrames() {
      throw new UnsupportedOperationException();
   }

   public final void join(long millis) throws InterruptedException {
      if (millis < 0L) {
         throw new IllegalArgumentException("timeout value is negative");
      } else {
         long startTime;
         if (this instanceof VirtualThread) {
            VirtualThread vthread = (VirtualThread)this;
            if (this.isAlive()) {
               startTime = TimeUnit.MILLISECONDS.toNanos(millis);
               vthread.joinNanos(startTime);
            }

         } else {
            synchronized(this) {
               if (millis > 0L) {
                  if (this.isAlive()) {
                     startTime = System.nanoTime();
                     long delay = millis;

                     do {
                        this.wait(delay);
                     } while(this.isAlive() && (delay = millis - TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) > 0L);
                  }
               } else {
                  while(this.isAlive()) {
                     this.wait(0L);
                  }
               }

            }
         }
      }
   }

   public final void join(long millis, int nanos) throws InterruptedException {
      if (millis < 0L) {
         throw new IllegalArgumentException("timeout value is negative");
      } else if (nanos >= 0 && nanos <= 999999) {
         if (this instanceof VirtualThread) {
            VirtualThread vthread = (VirtualThread)this;
            if (this.isAlive()) {
               long totalNanos = TimeUnit.MILLISECONDS.toNanos(millis);
               totalNanos += Math.min(Long.MAX_VALUE - totalNanos, (long)nanos);
               vthread.joinNanos(totalNanos);
            }

         } else {
            if (nanos > 0 && millis < Long.MAX_VALUE) {
               ++millis;
            }

            this.join(millis);
         }
      } else {
         throw new IllegalArgumentException("nanosecond timeout value out of range");
      }
   }

   public final void join() throws InterruptedException {
      this.join(0L);
   }

   public final boolean join(Duration duration) throws InterruptedException {
      long nanos = TimeUnit.NANOSECONDS.convert(duration);
      State state = this.threadState();
      if (state == State.NEW) {
         throw new IllegalThreadStateException("Thread not started");
      } else if (state == State.TERMINATED) {
         return true;
      } else if (nanos <= 0L) {
         return false;
      } else if (this instanceof VirtualThread) {
         VirtualThread vthread = (VirtualThread)this;
         return vthread.joinNanos(nanos);
      } else {
         long millis = TimeUnit.MILLISECONDS.convert(nanos, TimeUnit.NANOSECONDS);
         if (nanos > TimeUnit.NANOSECONDS.convert(millis, TimeUnit.MILLISECONDS)) {
            ++millis;
         }

         this.join(millis);
         return this.isTerminated();
      }
   }

   public static void dumpStack() {
      (new Exception("Stack trace")).printStackTrace();
   }

   public final void setDaemon(boolean on) {
      this.checkAccess();
      if (this.isVirtual() && !on) {
         throw new IllegalArgumentException("'false' not legal for virtual threads");
      } else if (this.isAlive()) {
         throw new IllegalThreadStateException();
      } else {
         if (!this.isVirtual()) {
            this.daemon(on);
         }

      }
   }

   void daemon(boolean on) {
      this.holder.daemon = on;
   }

   public final boolean isDaemon() {
      return this.isVirtual() ? true : this.holder.daemon;
   }

   /** @deprecated */
   @Deprecated(
      since = "17",
      forRemoval = true
   )
   public final void checkAccess() {
      SecurityManager security = System.getSecurityManager();
      if (security != null) {
         security.checkAccess(this);
      }

   }

   public String toString() {
      StringBuilder sb = new StringBuilder("Thread[#");
      sb.append(this.threadId());
      sb.append(",");
      sb.append(this.getName());
      sb.append(",");
      sb.append(this.getPriority());
      sb.append(",");
      ThreadGroup group = this.getThreadGroup();
      if (group != null) {
         sb.append(group.getName());
      }

      sb.append("]");
      return sb.toString();
   }

   @CallerSensitive
   public ClassLoader getContextClassLoader() {
      ClassLoader cl = this.contextClassLoader;
      if (cl == null) {
         return null;
      } else {
         if (!isSupportedClassLoader(cl)) {
            cl = ClassLoader.getSystemClassLoader();
         }

         SecurityManager sm = System.getSecurityManager();
         if (sm != null) {
            Class<?> caller = Reflection.getCallerClass();
            ClassLoader.checkClassLoaderPermission(cl, caller);
         }

         return cl;
      }
   }

   public void setContextClassLoader(ClassLoader cl) {
      SecurityManager sm = System.getSecurityManager();
      if (sm != null) {
         sm.checkPermission(new RuntimePermission("setContextClassLoader"));
      }

      if (!isSupportedClassLoader(this.contextClassLoader)) {
         throw new UnsupportedOperationException("The context class loader cannot be set");
      } else {
         this.contextClassLoader = cl;
      }
   }

   private static boolean isSupportedClassLoader(ClassLoader loader) {
      if (loader == null) {
         return true;
      } else if (loader == ClassLoaders.appClassLoader()) {
         return true;
      } else {
         return loader != Constants.NOT_SUPPORTED_CLASSLOADER;
      }
   }

   public static native boolean holdsLock(Object var0);

   public StackTraceElement[] getStackTrace() {
      if (this != currentThread()) {
         SecurityManager security = System.getSecurityManager();
         if (security != null) {
            security.checkPermission(SecurityConstants.GET_STACK_TRACE_PERMISSION);
         }

         if (!this.isAlive()) {
            return EMPTY_STACK_TRACE;
         } else {
            StackTraceElement[] stackTrace = this.asyncGetStackTrace();
            return stackTrace != null ? stackTrace : EMPTY_STACK_TRACE;
         }
      } else {
         return (new Exception()).getStackTrace();
      }
   }

   StackTraceElement[] asyncGetStackTrace() {
      Object stackTrace = this.getStackTrace0();
      if (stackTrace == null) {
         return null;
      } else {
         StackTraceElement[] stes = (StackTraceElement[])stackTrace;
         return stes.length == 0 ? null : StackTraceElement.of(stes);
      }
   }

   private native Object getStackTrace0();

   public static Map<Thread, StackTraceElement[]> getAllStackTraces() {
      SecurityManager security = System.getSecurityManager();
      if (security != null) {
         security.checkPermission(SecurityConstants.GET_STACK_TRACE_PERMISSION);
         security.checkPermission(SecurityConstants.MODIFY_THREADGROUP_PERMISSION);
      }

      Thread[] threads = getThreads();
      StackTraceElement[][] traces = dumpThreads(threads);
      Map<Thread, StackTraceElement[]> m = HashMap.newHashMap(threads.length);

      for(int i = 0; i < threads.length; ++i) {
         Thread thread = threads[i];
         StackTraceElement[] stackTrace = traces[i];
         if (!thread.isVirtual() && stackTrace != null) {
            m.put(threads[i], stackTrace);
         }
      }

      return m;
   }

   private static boolean isCCLOverridden(Class<?> cl) {
      return cl == Thread.class ? false : (Boolean)Caches.subclassAudits.get(cl);
   }

   private static boolean auditSubclass(Class<?> subcl) {
      Boolean result = (Boolean)AccessController.doPrivileged(new 1(subcl));
      return result;
   }

   static Thread[] getAllThreads() {
      // $FF: Couldn't be decompiled
   }

   private static native StackTraceElement[][] dumpThreads(Thread[] var0);

   private static native Thread[] getThreads();

   /** @deprecated */
   @Deprecated(
      since = "19"
   )
   public long getId() {
      return this.threadId();
   }

   public final long threadId() {
      return this.tid;
   }

   public State getState() {
      return this.threadState();
   }

   State threadState() {
      return VM.toThreadState(this.holder.threadStatus);
   }

   boolean isTerminated() {
      return this.threadState() == State.TERMINATED;
   }

   public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler ueh) {
      SecurityManager sm = System.getSecurityManager();
      if (sm != null) {
         sm.checkPermission(new RuntimePermission("setDefaultUncaughtExceptionHandler"));
      }

      defaultUncaughtExceptionHandler = ueh;
   }

   public static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler() {
      return defaultUncaughtExceptionHandler;
   }

   public UncaughtExceptionHandler getUncaughtExceptionHandler() {
      if (this.isTerminated()) {
         return null;
      } else {
         UncaughtExceptionHandler ueh = this.uncaughtExceptionHandler;
         return (UncaughtExceptionHandler)(ueh != null ? ueh : this.getThreadGroup());
      }
   }

   public void setUncaughtExceptionHandler(UncaughtExceptionHandler ueh) {
      this.checkAccess();
      this.uncaughtExceptionHandler(ueh);
   }

   void uncaughtExceptionHandler(UncaughtExceptionHandler ueh) {
      this.uncaughtExceptionHandler = ueh;
   }

   void dispatchUncaughtException(Throwable e) {
      this.getUncaughtExceptionHandler().uncaughtException(this, e);
   }

   static ThreadGroup virtualThreadGroup() {
      return Constants.VTHREAD_GROUP;
   }

   ThreadContainer threadContainer() {
      return this.container;
   }

   void setThreadContainer(ThreadContainer container) {
      this.container = container;
   }

   StackableScope headStackableScopes() {
      return this.headStackableScopes;
   }

   static void setHeadStackableScope(StackableScope scope) {
      currentThread().headStackableScopes = scope;
   }

   private native void setPriority0(int var1);

   private native void stop0(Object var1);

   private native void suspend0();

   private native void resume0();

   private native void interrupt0();

   private static native void clearInterruptEvent();

   private native void setNativeName(String var1);

   private static native long getNextThreadIdOffset();

   static {
      registerNatives();
      EMPTY_STACK_TRACE = new StackTraceElement[0];
   }
}
