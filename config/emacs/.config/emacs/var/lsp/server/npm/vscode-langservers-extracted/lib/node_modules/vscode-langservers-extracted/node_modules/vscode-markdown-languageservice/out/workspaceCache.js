"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.MdWorkspaceInfoCache = exports.MdDocumentInfoCache = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const dispose_1 = require("./util/dispose");
const lazy_1 = require("./util/lazy");
const resourceMap_1 = require("./util/resourceMap");
/**
 * Cache of information per-document in the workspace.
 *
 * The values are computed lazily and invalidated when the document changes.
 */
class MdDocumentInfoCache extends dispose_1.Disposable {
    constructor(workspace, getValue) {
        super();
        this.workspace = workspace;
        this.getValue = getValue;
        this._cache = new resourceMap_1.ResourceMap();
        this._loadingDocuments = new resourceMap_1.ResourceMap();
        this._register(this.workspace.onDidChangeMarkdownDocument(doc => this.invalidate(doc)));
        this._register(this.workspace.onDidDeleteMarkdownDocument(this.onDidDeleteDocument, this));
    }
    async get(resource) {
        let existing = this._cache.get(resource);
        if (existing) {
            return existing.value.value;
        }
        const doc = await this.loadDocument(resource);
        if (!doc) {
            return undefined;
        }
        // Check if we have invalidated
        existing = this._cache.get(resource);
        if (existing) {
            return existing.value.value;
        }
        return this.resetEntry(doc)?.value;
    }
    async getForDocument(document) {
        const existing = this._cache.get(vscode_uri_1.URI.parse(document.uri));
        if (existing) {
            return existing.value.value;
        }
        return this.resetEntry(document).value;
    }
    loadDocument(resource) {
        const existing = this._loadingDocuments.get(resource);
        if (existing) {
            return existing;
        }
        const p = this.workspace.openMarkdownDocument(resource);
        this._loadingDocuments.set(resource, p);
        p.finally(() => {
            this._loadingDocuments.delete(resource);
        });
        return p;
    }
    resetEntry(document) {
        // TODO: cancel old request?
        const cts = new vscode_languageserver_1.CancellationTokenSource();
        const value = (0, lazy_1.lazy)(() => this.getValue(document, cts.token));
        this._cache.set(vscode_uri_1.URI.parse(document.uri), { value, cts });
        return value;
    }
    invalidate(document) {
        if (this._cache.has(vscode_uri_1.URI.parse(document.uri))) {
            this.resetEntry(document);
        }
    }
    onDidDeleteDocument(resource) {
        const entry = this._cache.get(resource);
        if (entry) {
            entry.cts.cancel();
            entry.cts.dispose();
            this._cache.delete(resource);
        }
    }
}
exports.MdDocumentInfoCache = MdDocumentInfoCache;
/**
 * Cache of information across all markdown files in the workspace.
 *
 * Unlike {@link MdDocumentInfoCache}, the entries here are computed eagerly for every file in the workspace.
 * However the computation of the values is still lazy.
 */
class MdWorkspaceInfoCache extends dispose_1.Disposable {
    constructor(_workspace, _getValue) {
        super();
        this._workspace = _workspace;
        this._getValue = _getValue;
        this._cache = new resourceMap_1.ResourceMap();
        this._register(this._workspace.onDidChangeMarkdownDocument(this.onDidChangeDocument, this));
        this._register(this._workspace.onDidCreateMarkdownDocument(this.onDidChangeDocument, this));
        this._register(this._workspace.onDidDeleteMarkdownDocument(this.onDidDeleteDocument, this));
    }
    async entries() {
        await this.ensureInit();
        return Promise.all(Array.from(this._cache.entries(), async ([k, v]) => {
            return [k, await v.value.value];
        }));
    }
    async values() {
        await this.ensureInit();
        return Promise.all(Array.from(this._cache.entries(), x => x[1].value.value));
    }
    async getForDocs(docs) {
        for (const doc of docs) {
            if (!this._cache.has(vscode_uri_1.URI.parse(doc.uri))) {
                this.update(doc);
            }
        }
        return Promise.all(docs.map(doc => this._cache.get(vscode_uri_1.URI.parse(doc.uri)).value.value));
    }
    async ensureInit() {
        if (!this._init) {
            this._init = this.populateCache();
        }
        await this._init;
    }
    async populateCache() {
        const markdownDocuments = await this._workspace.getAllMarkdownDocuments();
        for (const document of markdownDocuments) {
            if (!this._cache.has(vscode_uri_1.URI.parse(document.uri))) {
                this.update(document);
            }
        }
    }
    update(document) {
        // TODO: cancel old request?
        const cts = new vscode_languageserver_1.CancellationTokenSource();
        this._cache.set(vscode_uri_1.URI.parse(document.uri), {
            value: (0, lazy_1.lazy)(() => this._getValue(document, cts.token)),
            cts
        });
    }
    onDidChangeDocument(document) {
        this.update(document);
    }
    onDidDeleteDocument(resource) {
        const entry = this._cache.get(resource);
        if (entry) {
            entry.cts.cancel();
            entry.cts.dispose();
            this._cache.delete(resource);
        }
    }
}
exports.MdWorkspaceInfoCache = MdWorkspaceInfoCache;
//# sourceMappingURL=workspaceCache.js.map