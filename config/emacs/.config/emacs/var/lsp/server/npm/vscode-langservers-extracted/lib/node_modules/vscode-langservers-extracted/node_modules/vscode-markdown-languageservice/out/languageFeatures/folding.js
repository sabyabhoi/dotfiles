"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.MdFoldingProvider = void 0;
const lsp = require("vscode-languageserver-types");
const logging_1 = require("../logging");
const textDocument_1 = require("../types/textDocument");
const string_1 = require("../util/string");
const rangeLimit = 5000;
class MdFoldingProvider {
    #parser;
    #tocProvider;
    #logger;
    constructor(parser, tocProvider, logger) {
        this.#parser = parser;
        this.#tocProvider = tocProvider;
        this.#logger = logger;
    }
    async provideFoldingRanges(document, token) {
        this.#logger.log(logging_1.LogLevel.Debug, 'MdFoldingProvider', `provideFoldingRanges â€” ${document.uri} ${document.version}`);
        const foldables = await Promise.all([
            this.#getRegions(document, token),
            this.#getHeaderFoldingRanges(document, token),
            this.#getBlockFoldingRanges(document, token)
        ]);
        return foldables.flat().slice(0, rangeLimit);
    }
    async #getRegions(document, token) {
        const tokens = await this.#parser.tokenize(document);
        if (token.isCancellationRequested) {
            return [];
        }
        const regionMarkers = tokens.filter(isRegionMarker)
            .map(token => ({ line: token.map[0], isStart: isStartRegion(token.content) }));
        const nestingStack = [];
        return regionMarkers
            .map((marker) => {
            if (marker.isStart) {
                nestingStack.push(marker);
            }
            else if (nestingStack.length && nestingStack[nestingStack.length - 1].isStart) {
                return { startLine: nestingStack.pop().line, endLine: marker.line, kind: lsp.FoldingRangeKind.Region };
            }
            else {
                // noop: invalid nesting (i.e. [end, start] or [start, end, end])
            }
            return null;
        })
            .filter((region) => !!region);
    }
    async #getHeaderFoldingRanges(document, token) {
        const toc = await this.#tocProvider.getForDocument(document);
        if (token.isCancellationRequested) {
            return [];
        }
        return toc.entries.map((entry) => {
            let endLine = entry.sectionLocation.range.end.line;
            if ((0, string_1.isEmptyOrWhitespace)((0, textDocument_1.getLine)(document, endLine)) && endLine >= entry.line + 1) {
                endLine = endLine - 1;
            }
            return { startLine: entry.line, endLine };
        });
    }
    async #getBlockFoldingRanges(document, token) {
        const tokens = await this.#parser.tokenize(document);
        if (token.isCancellationRequested) {
            return [];
        }
        const multiLineListItems = tokens.filter(isFoldableToken);
        return multiLineListItems.map(listItem => {
            const start = listItem.map[0];
            let end = listItem.map[1] - 1;
            if ((0, string_1.isEmptyOrWhitespace)((0, textDocument_1.getLine)(document, end)) && end >= start + 1) {
                end = end - 1;
            }
            return { startLine: start, endLine: end, kind: this.#getFoldingRangeKind(listItem) };
        });
    }
    #getFoldingRangeKind(listItem) {
        return listItem.type === 'html_block' && listItem.content.startsWith('<!--')
            ? lsp.FoldingRangeKind.Comment
            : undefined;
    }
}
exports.MdFoldingProvider = MdFoldingProvider;
const isStartRegion = (t) => /^\s*<!--\s*#?region\b.*-->/.test(t);
const isEndRegion = (t) => /^\s*<!--\s*#?endregion\b.*-->/.test(t);
const isRegionMarker = (token) => !!token.map && token.type === 'html_block' && (isStartRegion(token.content) || isEndRegion(token.content));
const isFoldableToken = (token) => {
    if (!token.map) {
        return false;
    }
    switch (token.type) {
        case 'fence':
        case 'list_item_open':
            return token.map[1] > token.map[0];
        case 'html_block':
            if (isRegionMarker(token)) {
                return false;
            }
            return token.map[1] > token.map[0] + 1;
        default:
            return false;
    }
};
//# sourceMappingURL=folding.js.map